#!/usr/bin/env python3

import os
import sys
import yaml
import re

from types import SimpleNamespace
from base64 import b64encode, b64decode

PLACEHOLDER_PROG = re.compile(r'\$\{\s*(\w+)\s*\}')

def eprint(*args, **kwargs):
    """
    Print to stderr.
    """
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

def load_config():
    """
    Load plugin configurations.
    :return: a namespace containing the configurations
    :rtype: SimpleNamespace
    """
    # load
    with open(sys.argv[1], 'r') as f:
        plugin_config = yaml.safe_load(f)
        placeholder_file = plugin_config.get('placeholderFile')
        resource_selectors = plugin_config.get('resourceSelectors', [])

    # validation
    validation_fail = False
    if not placeholder_file:
        eprint('placeholderFile is required')
        validation_fail = True
    if validation_fail:
        sys.exit(1)

    return SimpleNamespace(
        placeholder_file=placeholder_file,
        resource_selectors=resource_selectors
    )

def parse_dotenv(filename):
    """
    Load and parse a file in the dotenv format. Exit on error.
    :param str filename: the path the the file to load
    :return: a dict of key/value loaded from the file
    :rtype: dict
    """
    values = {}
    linenum = 0
    try:
        with open(filename, 'r') as f:
            for line in f.readlines():
                linenum += 1
                if line and not line.startswith('#'):
                    key, value = line.rstrip('\n').split('=', 1)
                    values[key] = value
    except ValueError:
        eprint('%s: line %s: invalid format' % (filename, linenum))
        sys.exit(1)
    return values

def perform_placeholder_replacements(is_secret, placeholders, data):
    """
    Recursively perform placeholder replacement to arbitrary data.
    :param bool is_secret: wether the the data is from a secret that need to be base64 decoded
    :param dict placeholders: a dict of placeholders for the replacements
    :param data: the data to operate on. can be of any type, but replacement will only be performed on list, dict or str
    :rtype: same type then data
    """
    def do_replacement(match):
        """
        Perform the replacement. If the matched value is absent from the placeholders, no replacement is performed
        :param Match match: the match object with a single capture group
        :return: the replacement
        :rtype: str
        """
        placeholder = placeholders.get(match.group(1))
        if placeholder:
            return placeholder
        else:
            return match.group(0)

    if isinstance(data, dict):
        result = {}
        for key, value in data.items():
            result[key] = perform_placeholder_replacements(is_secret, placeholders, value)
        return result
    elif isinstance(data, list):
        result = []
        for value in data:
            result.append(perform_placeholder_replacements(is_secret, placeholders, value))
        return result
    elif isinstance(data, str):
        if is_secret:
            return b64encode(PLACEHOLDER_PROG.sub(do_replacement, b64decode(data, validate=False).decode()).encode()).decode()
        else:
            return PLACEHOLDER_PROG.sub(do_replacement, data)
    else:
        return data

def kustomize_placeholder_transformer():
    """
    Perform key/value replacements in kubernetes resources.
    """
    config = load_config()
    placeholders = parse_dotenv(config.placeholder_file)
    all_resources = []

    for resource in yaml.safe_load_all(sys.stdin.read()):
        # extract all the fields for selector matching
        resource_component = resource.get('apiVersion').split('/')
        if len(resource_component) == 1:
            group = 'apps'
            version = resource_component[0]
        else:
            group = resource_component[0]
            version = resource_component[1]
        resource_spec = {
            'group': group,
            'version': version,
            'kind': resource.get('kind'),
            'name': resource.get('metadata').get('name'),
            'namespace': resource.get('metadata').get('namespace', 'default')
        }

        do_placeholder_replacements = False
        if config.resource_selectors:
            # check if the resource match a selector
            for selector in config.resource_selectors:
                match = True
                for name, value in selector.items():
                    if resource_spec.get(name) != value:
                        # no match, we break out
                        match = False
                        break
                if match:
                    # we have a match, we can perform placeholder replacement
                    do_placeholder_replacements = True
                    break
        else:
            # if there is no selector, we perform replacement in all the resources
            do_placeholder_replacements = True
        
        if do_placeholder_replacements:
            for key, value in resource.items():
                # secret is a special case
                if(resource_spec['kind'] == 'Secret'):
                    resource['data'] = perform_placeholder_replacements(True, placeholders, resource['data'])
                # exclude these top-level fields from placeholder replacement
                elif key not in ('apiVersion', 'kind', 'metadata'):
                    resource[key] = perform_placeholder_replacements(False, placeholders, value)

        all_resources.append(resource)
    yaml.dump_all(all_resources, sys.stdout, default_flow_style=False)

if __name__ == '__main__':
    kustomize_placeholder_transformer()
